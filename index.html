<!DOCTYPE html>
<html lang="ja">
<head>
  <base href="/pushup_counter_web/">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="description" content="Offline push-up counter with on-device pose & face (Flutter + MediaPipe).">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="pushup_counter">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">
  <link rel="icon" type="image/png" href="favicon.png"/>
  <link rel="manifest" href="manifest.json">
  <title>pushup_counter</title>

  <style>
    html, body { height: 100%; margin: 0; background: #000; }

    #flt-glass-pane, #flutter_view, flt-glass-pane {
      position: relative !important;
      z-index: 9999 !important;
      pointer-events: auto !important;
    }
    canvas, flt-canvas { z-index: 9999 !important; }

    .no-js {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      color: #fff; text-align: center; padding: 24px; background:#000;
    }
  </style>

  <!-- ===== Pose Landmarker 部分（外カメラ切替対応） ===== -->
  <script type="module">
    import { PoseLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

    const isHttps = (location.protocol === 'https:' || location.hostname === 'localhost');
    const emit = (name, detail) =>
      window.dispatchEvent(new CustomEvent(name, { detail }));

    // ★ facing: 'front' | 'back'
    const pose = {
      stream: null,
      video: null,
      raf: null,
      landmarker: null,
      facing: 'front',
      running: false,
    };

    function ensurePoseVideo() {
      if (pose.video) return;
      const v = document.createElement('video');
      v.id = 'pose-video';
      Object.assign(v.style, {
        position: 'fixed',
        left: '0',
        top: '0',
        width: '100vw',
        height: '100vh',
        objectFit: 'cover',
        transform: 'scaleX(-1)',     // ★ 初期はフロント（ミラー）
        zIndex: '0',
        pointerEvents: 'none',
        background: 'black',
      });
      v.autoplay = true;
      v.muted = true;
      v.playsInline = true; // iOS Safari 向け
      v.setAttribute('playsinline', 'true');
      document.body.appendChild(v);
      pose.video = v;
    }

    async function poseStartCamera() {
      ensurePoseVideo();

      const isFront = (pose.facing !== 'back');

      const videoConstraints = isFront
        ? {
            facingMode: 'user',
            width: { ideal: 1280 },
            height: { ideal: 720 },
          }
        : {
            facingMode: { exact: 'environment' }, // ← iOS で安定しやすい
            width: { ideal: 1280 },
            height: { ideal: 720 },
          };

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: videoConstraints,
          audio: false,
        });
        pose.stream = stream;
        pose.video.srcObject = stream;
        await pose.video.play();

        // ★ カメラ向きイベント（Flutter側でHUD表示などに使いたければ）
        emit('facing', { value: isFront ? 'front' : 'back' });

        // ★ フロントのときだけミラー表示
        pose.video.style.transform = isFront ? 'scaleX(-1)' : 'none';
      } catch (e) {
        emit('face:onError', { message: 'getUserMedia 失敗: ' + String(e) });
        throw e;
      }
    }

    async function ensurePoseLandmarker() {
      if (pose.landmarker) return pose.landmarker;
      const fileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );
      pose.landmarker = await PoseLandmarker.createFromOptions(fileset, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
        },
        runningMode: "VIDEO",
        numPoses: 1,
        minPoseDetectionConfidence: 0.4,
        minPosePresenceConfidence: 0.4,
        minTrackingConfidence: 0.4,
      });
      return pose.landmarker;
    }

    function toNamedPose(lm) {
      if (!lm || !lm.length) return null;
      const p = (i) => ({ x: lm[i].x, y: lm[i].y });
      return {
        leftShoulder: p(11), rightShoulder: p(12),
        leftElbow:    p(13), rightElbow:    p(14),
        leftWrist:    p(15), rightWrist:    p(16),
        leftHip:      p(23), rightHip:      p(24),
        leftKnee:     p(25), rightKnee:     p(26),
        leftAnkle:    p(27), rightAnkle:    p(28),
      };
    }

    function poseLoop() {
      if (!pose.running) return;
      if (!pose.landmarker || !pose.video) {
        pose.raf = requestAnimationFrame(poseLoop);
        return;
      }

      const now = performance.now();
      try {
        const res = pose.landmarker.detectForVideo(pose.video, now);
        if (res?.landmarks?.length) {
          const named = toNamedPose(res.landmarks[0]);
          if (named) emit('pose', { landmarks: named });
        }
      } catch (e) {
        emit('face:onError', { message: 'pose detectForVideo 失敗: ' + String(e) });
      }
      pose.raf = requestAnimationFrame(poseLoop);
    }

    // === Flutter側から呼ぶ関数を global に生やす =======================
    // ★ ポーズ開始
    window.poseStart = async function () {
      try {
        if (!isHttps) {
          emit('face:onError', { message: 'HTTPS でアクセスしてください（カメラ権限が必要）' });
        }

        // 初期値はフロント
        pose.facing = 'front';
        pose.running = true;

        await poseStartCamera();
        await ensurePoseLandmarker();

        if (pose.raf) cancelAnimationFrame(pose.raf);
        pose.raf = requestAnimationFrame(poseLoop);
      } catch (e) {
        emit('face:onError', { message: 'poseStart 失敗: ' + String(e) });
      }
    };

    // ★ カメラ Front / Back 切り替え
    window.poseSwitchCamera = async function () {
      try {
        // 既存ストリームを停止
        if (pose.stream) {
          try { pose.stream.getTracks().forEach(t => t.stop()); } catch (_) {}
          pose.stream = null;
        }

        // 向きをトグル
        pose.facing = (pose.facing === 'front') ? 'back' : 'front';

        // 新しいカメラで再取得（landmarker は再利用）
        await poseStartCamera();

        // 念のためループを再開
        if (!pose.running) {
          pose.running = true;
        }
        if (pose.raf) {
          cancelAnimationFrame(pose.raf);
        }
        pose.raf = requestAnimationFrame(poseLoop);
      } catch (e) {
        emit('face:onError', { message: 'poseSwitchCamera 失敗: ' + String(e) });
      }
    };

    // ★ 停止
    window.poseStop = async function () {
      pose.running = false;
      if (pose.raf) {
        cancelAnimationFrame(pose.raf);
        pose.raf = null;
      }

      try { await pose.landmarker?.close?.(); } catch (_) {}
      pose.landmarker = null;

      if (pose.stream) {
        try { pose.stream.getTracks().forEach(t => t.stop()); } catch (_) {}
        pose.stream = null;
      }

      if (pose.video) {
        try { pose.video.pause(); pose.video.srcObject = null; } catch (_) {}
        try { pose.video.remove(); } catch (_) {}
        pose.video = null;
      }
      // facing は次回 poseStart で front にリセット
    };

    // JS全体のエラーを Flutter 側に送る
    window.addEventListener('error', e =>
      emit('face:onError', { message: String(e?.message ?? e) })
    );
    window.addEventListener('unhandledrejection', e =>
      emit('face:onError', { message: String(e?.reason ?? e) })
    );
  </script>

  <!-- Face Runtime -->
  <script type="module" src="face_runtime.js"></script>

  <!-- Face Module（Flutter <-> JS）-->
  <script type="module" src="face_module.js"></script>

  <!-- ※※ ゴースト UI（ghost-bar / ghost-help）は完全削除済み ※※ -->
</head>

<body>
  <noscript>
    <div class="no-js">
      このアプリを利用するには JavaScript を有効にしてください。カメラの許可も必要です（HTTPS 接続必須、localhost は例外）。
    </div>
  </noscript>

  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
